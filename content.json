{"meta":{"title":"Walton","subtitle":"","description":"","author":"Walton","url":"https://waltonmax.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-08-11T02:49:10.962Z","updated":"2020-08-11T02:49:10.962Z","comments":false,"path":"about/index.html","permalink":"https://waltonmax.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-08-11T02:49:10.963Z","updated":"2020-08-11T02:49:10.963Z","comments":false,"path":"tags/index.html","permalink":"https://waltonmax.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-11T02:49:10.962Z","updated":"2020-08-11T02:49:10.962Z","comments":false,"path":"categories/index.html","permalink":"https://waltonmax.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mongodb备份与恢复","slug":"database-mongodb-backup","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T09:46:06.480Z","comments":false,"path":"2020/08/12/database-mongodb-backup/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/database-mongodb-backup/","excerpt":"","text":"mongodump备份/恢复 12345678910111213141516#进入容器docker exec -itd mongodb bash#备份全部数据库 单个数据库 -d database-namemongodump -h 127.0.0.1:27017 -u mongoadmin -p pwd --authenticationDatabase &quot;admin&quot; -o /data/db/bak#压缩为.tar.gz格式tar -zcvf mongodb.tar.gz bak/#复制\\cp -r /data/mongodb/mongo-data/bak /data/mongodb/mongo-data/bak#恢复全部数据库docker exec -it mongodb bashmongorestore -u mongoadmin -p pwd --drop --authenticationDatabase &quot;admin&quot; --dir /data/db/bak mongorestore恢复数据默认是追加，如打算先删除后导入，可以加上–drop参数，不过添加–drop参数后，会将数据库数据清空后再导入，如果数据库备份后又新加入了数据，也会将新加的数据删除，它不像mysql有一个存在的判断。 1234567891011121314151617181920212223242526#备份单个表mongodump -u user_name -p password --port 27010 --authenticationDatabase admin -d db_name -c table_name -o /backup/table_name.bak#备份单个库mongodump -u user_name -p password --port 27010 --authenticationDatabase admin -d db_name -o /backup/db_name/#备份所有库mongodump -u user_name -p password --port 27010 --authenticationDatabase admin -o /backup/all_db/# 备份所有库推荐使用添加--oplog参数的命令，这样的备份是基于某一时间点的快照，只能用于备份全部库时才可用，单库和单表不适用：mongodump -u user_name -p password --port 27010 --authenticationDatabase admin --oplog -o /backup/all_db/ # 同时，恢复时也要加上--oplogReplay参数，具体命令如下(下面是恢复单库的命令)：mongorestore -u user_name -p password --port 27010 --authenticationDatabase admin --oplogReplay /backup/all_db/#mongodump在mongo关闭时，也是可以备份的，不过需要指定数据目录，命令为：mongodump --dbpath /data/db#恢复单个库mongorestore -u user_name -p password --port 27010 --authenticationDatabase admin db_name /backup/db_name/#恢复所有库mongorestore -u user_name -p password --port 27010 --authenticationDatabase admin /backup/all_db/#恢复单表mongorestore -u user_name -p password --port 27010 --authenticationDatabase admin -d db_name -c table_name /backup/table_name/table_name/table_name.bson mongoexport备份/还原 1234567891011121314151617181920#导出文件格式支持csv和json，不同的是csv格式必须显示的指定要导出的字段,而json格式则不需要mongoexport --port 21017 -u user -p&#x27;password&#x27; -d db_name -c table_name -f col1,col2,col3 --type=csv -o ./table_name.csv --authenticationDatabase db_name# 导出所有字段数据mongoexport --port 21017 -u user -p&#x27;password&#x27; -d db_name -c table_name -o ./table_name.json --type=json --authenticationDatabase db_name#`mongoimport`还原#命令用来导入数据，语法和mongoexport差不多将table_name.csv里的数据导入到db_name数据库中的table_name数据表中,如果table_name数据表不存在则自动创建# headerline 仅适用于导入csv,tsv格式的数据，表示文件中的第一行作为数据头# upsert 以新增或者更新的方式来导入数据mongoimport --port 21017 -u user -p&#x27;password&#x27; -d db_name -c table_name --type=csv --file ./table_name.csv --headerline --upsert#备份脚本#!/bin/bashmongo_bin=/usr/local/mongodb/binback_path=/root/mongodbbackupfile_date=`date +&quot;%Y-%m-%d&quot;`$mongo_bin&#125;/mongodump -h 127.0.0.1:27010 -o $&#123;back_path&#125;/$&#123;file_date&#125;tar zcvPf $&#123;back_path&#125;/$&#123;file_date&#125;.tar.gz $&#123;back_path&#125;/$&#123;file_date&#125; --remove-filesfind /root/mongodbbackup/* -type f -mtime +10 -exec rm -f &#123;&#125; \\; 部分参数说明 –drop参数：恢复数据之前删除原来的数据，避免数据重复 –noIndexRestore参数：恢复数据时不创建索引 –dir参数：数据库备份目录 -d参数：后面跟要恢复的数据库名称 自动备份脚本 123456789101112131415161718192021222324252627282930#!/bin/bash#backup MongoDB#mongodump命令路径DUMP=/usr/local/mongodb/bin/mongodump#临时备份目录OUT_DIR=/data/mongodb_bak/mongodb_bak_now#备份存放路径TAR_DIR=/data/mongodb_bak/mongodb_bak_list#获取当前系统时间DATE=`date +%Y_%m_%d`#数据库账号DB_USER=user#数据库密码DB_PASS=123#DAYS=15代表删除15天前的备份，即只保留近15天的备份DAYS=15#最终保存的数据库备份文件TAR_BAK=&quot;mongodb_bak_$DATE.tar.gz&quot;cd $OUT_DIRrm -rf $OUT_DIR/*mkdir -p $OUT_DIR/$DATE#备份全部数据库$DUMP -h 15.62.32.112:27017 -u $DB_USER -p $DB_PASS --authenticationDatabase &quot;admin&quot; -o $OUT_DIR/$DATE#压缩为.tar.gz格式tar -zcvf $TAR_DIR/$TAR_BAK $OUT_DIR/$DATE#删除15天前的备份文件find $TAR_DIR/ -mtime +$DAYS -deleteexit","categories":[{"name":"数据库","slug":"数据库","permalink":"https://waltonmax.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://waltonmax.github.io/tags/mongodb/"}]},{"title":"mysql备份与恢复","slug":"database-mysql-backup","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T09:47:19.072Z","comments":false,"path":"2020/08/12/database-mysql-backup/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/database-mysql-backup/","excerpt":"","text":"123456789101112131415161718192021222324#导出所有数据mysqldump -uroot -proot --all-databases &gt;&#x2F;tmp&#x2F;all.sql#导出单个mysqldump -uroot -proot --databases db1 db2 &gt;&#x2F;tmp&#x2F;user.sql#导出db1中的a1、a2表mysqldump -uroot -proot --databases db1 --tables a1 a2 &gt;&#x2F;tmp&#x2F;db1.sql#条件导出，导出db1表a1中id&#x3D;1的数据mysqldump -uroot -proot --databases db1 --tables a1 --where&#x3D;&#39;id&#x3D;1&#39; &gt;&#x2F;tmp&#x2F;a1.sql#只导出表结构不导出数据，--no-datamysqldump -uroot -proot --no-data --databases db1 &gt;&#x2F;tmp&#x2F;db1.sql#跨服务器导出导入数据mysqldump --host&#x3D;h1 -uroot -proot --databases db1 |mysql --host&#x3D;h2 -uroot -proot db2#将h1服务器中的db1数据库的所有数据导入到h2中的db2数据库中，db2的数据库必须存在否则会报错mysqldump --host&#x3D;192.168.80.137 -uroot -proot -C --databases test |mysql --host&#x3D;192.168.80.133 -uroot -proot test #恢复导入数据库数据mysql -uroot -p&#39;123456&#39; mytest &lt; &#x2F;mnt&#x2F;mytest_bak.sql","categories":[{"name":"数据库","slug":"数据库","permalink":"https://waltonmax.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://waltonmax.github.io/tags/mysql/"}]},{"title":"mysql重置密码","slug":"database-mysql-reset-password","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T09:47:37.451Z","comments":false,"path":"2020/08/12/database-mysql-reset-password/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/database-mysql-reset-password/","excerpt":"","text":"12345678910111213141516171819202122232425# 进入容器docker exec -it mysql bash# 设置跳过权限表的加载 # 警告：这就意味着任何用户都能登录进来，并进行任何操作，相当不安全。echo &quot;skip-grant-tables&quot; &gt;&gt; &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;docker.cnf# 退出容器exit# 重启容器docker restart mysql# 再次进入容器docker exec -it mysql bash# 登录 mysql（无需密码）mysql -uroot # 更新权限flush privileges;# 修改密码alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;# 退出mysqlexit# 替换掉刚才加的跳过权限表的加载参数sed -i &quot;s&#x2F;skip-grant-tables&#x2F; &#x2F;&quot; &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;docker.cnf# 退出容器exit# 重启容器docker restart mysql","categories":[{"name":"数据库","slug":"数据库","permalink":"https://waltonmax.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://waltonmax.github.io/tags/mysql/"}]},{"title":"Git 工作流与规范","slug":"git-flow-guide","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T10:04:41.288Z","comments":false,"path":"2020/08/12/git-flow-guide/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/git-flow-guide/","excerpt":"","text":"分支约定 Git Flow有主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动；辅助分支组织为了解决特定的问题而进行的各种开发活动。 主分支 主分支是所有开发活动的核心分支。所有的开发活动产生的输出物最终都会反映到主分支的代码中。主分支分为master分支和develop分支。 master 分支 master分支存放的是随时可供在生产环境中部署的稳定版本代码 master分支保存官方发布版本历史，release tag标识不同的发布版本 一个项目只能有一个master分支 仅在发布新的可供部署的代码时才更新master分支上的代码 每次更新master，都需对master添加指定格式的tag，用于发布或回滚 master分支是保护分支，不可直接push到远程仓master分支 master分支代码只能被release分支或hotfix分支合并 develop 分支 develop分支是保存当前最新开发成果的分支 一个项目只能有一个develop分支 develop分支衍生出各个feature分支 develop分支是保护分支，不可直接push到远程仓库develop分支 develop分支不能与master分支直接交互 辅助分支 辅助分支是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。这些分支与主分支不同，通常只会在有限的时间范围内存在。 辅助分支包括： 用于开发新功能时所使用的feature分支 用于辅助版本发布的release分支 用于修正生产代码中的缺陷的hotfix分支 以上这些分支都有固定的使用目的和分支操作限制。从单纯技术的角度说，这些分支与Git其他分支并没有什么区别，但通过命名，我们定义了使用这些分支的方法。 feature 分支 使用规范： 命名规则：feature/* develop分支的功能分支 feature分支使用develop分支作为它们的父类分支 以功能为单位从develop拉一个feature分支 每个feature分支颗粒要尽量小，以利于快速迭代和避免冲突 当其中一个feature分支完成后，它会合并回develop分支 当一个功能因为各种原因不开发了或者放弃了，这个分支直接废弃，不影响develop分支 feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里 feature分支只与develop分支交互，不能与master分支直接交互 如有几个同事同时开发，需要分割成几个小功能，每个人都需要从develop中拉出一个feature分支，但是每个feature颗粒要尽量小，因为它需要我们能尽早merge回develop分支，否则冲突解决起来就没完没了。同时，当一个功能因为各种原因不开发了或者放弃了，这个分支直接废弃，不影响develop分支。 release 分支 使用规范： 命名规则：release/*，“*”以本次发布的版本号为标识 release分支主要用来为发布新版的测试、修复做准备 当需要为发布新版做准备时，从develop衍生出一个release分支 release分支可以从develop分支上指定commit派生出 release分支测试通过后，合并到master分支并且给master标记一个版本号 release分支一旦建立就将独立，不可再从其他分支pull代码 必须合并回develop分支和master分支 release分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等）。通过在release分支上进行这些工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。 当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，我们就可以考虑准备创建release分支了。而所有在当前即将发布的版本之外的业务需求一定要确保不能混到release分支之内（避免由此引入一些不可控的系统缺陷）。 成功的派生了release分支，并被赋予版本号之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。版本号的命名可以依据项目定义的版本号命名规则进行。 hotfix 分支 使用规范： 命名规则：hotfix/* hotfix分支用来快速给已发布产品修复bug或微调功能 只能从master分支指定tag版本衍生出来 一旦完成修复bug，必须合并回master分支和develop分支 master被合并后，应该被标记一个新的版本号 hotfix分支一旦建立就将独立，不可再从其他分支pull代码 除了是计划外创建的以外，hotfix分支与release分支十分相似：都可以产生一个新的可供在生产环境部署的软件版本。 当生产环境中的软件遇到了异常情况或者发现了严重到必须立即修复的软件缺陷的时候，就需要从master分支上指定的TAG版本派生hotfix分支来组织代码的紧急修复工作。 这样做的显而易见的好处是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。 使用规范 所有使用了本规范的项目，必须严格规范操作，否则不予以合并代码、提测、打包上线等后续操作。 基本要求 所有commit必须有注释，内容必须简洁明了的描述本次commit涵盖了哪些内容。严禁注释内容过于简单或不能明确表达提交内容的！ 合理控制提交内容的颗粒度，一次commit含一个独立功能点。严禁一次提交涵盖多个功能项。 正确为每个项目设置Git提交用到的user.name和user.email信息，以公司邮箱为准，不可随意设置以影响无法正确识别。 查看当前项目配置信息的命令：git config -l 版本号(tag) 版本号(tag)命名规则：主版本号.次版本号.修订号，如2.1.13。(遵循GitHub[语义化版本]命名规范) 版本号仅标记于master分支，用于标识某个可发布/回滚的版本代码 对master标记tag意味着该tag能发布到生产环境 对master分支代码的每一次更新(合并)必须标记版本号 仅项目管理员有权限对master进行合并和标记版本号 项目权限 Git权限分管理员、开发者、浏览者三种类型 浏览者只能浏览代码，无push、pull request等所有写权限 开发者拥有浏览、push非主分支、提交pull request工单权限 管理员拥有建立和管理Git项目、合并分支和代码、给master打tag版本号等权限 分支使用 每个Git项目固定含有上述所有分支类型。主分支master和develop是保护分支，只能进行合并请求，均不可直接提交代码。 功能需求或常规Bug修复，请从develop拉取feature分支；线上紧急问题修复，请从master拉去hotfix分支。 代码提交 一个提交就代表解决一个问题 大问题适当地分解为多个小问题，以便每次小型提交都更易于理解 注释格式 第1行，标题行，对提交的简要总结，长度不超过50个字符，用语采用命令式而非过去式 第2行，空行 第3行开始，正文内容，对改动的详细介绍），可以是多行内容，建议每行长度不超过72个字符 正文用于解释是什么和为什么，而不是如何做 如果有对应的issue，则将issue的id或链接放在注释正文中 并非强制所有提交都要求3行+格式的注释，但除非标题行内容就能清晰的描述提交内容，否则必须采用3行+的注释格式 为什么要约定注释格式？ 1. 加快 Reviewing Code 的过程 2. 帮助我们写好 release note 3. 5年后帮你快速想起来某个分支，tag 或者 commit 增加了什么功能，改变了哪些代码 4. 让其他的开发者在运行 git blame 的时候想跪谢 5. 其他小伙伴不会出现想抽你的冲动 6. 总之，一个好的提交信息，会帮助你提高项目的整体质量 看看 Linus Torvalds 在Linux项目上写的提交注释：https://github.com/torvalds/linux/commits/master 以及 Linus Torvalds 关于提交注释的讨论：https://github.com/torvalds/linux/pull/17#issuecomment-5659933 如果怕自己忘记或尚未养成习惯，可以设置模板： 12345678950-character subject line72-character wrapped longer description. This should answer:* Why was this change necessary?* How does it address the problem?* Are there any side effects?Include a link to the ticket, if any. 下面是一则推荐的提交注释内容： 12345678910Redirect user to the requested page after loginhttps:&#x2F;&#x2F;trello.com&#x2F;path&#x2F;to&#x2F;relevant&#x2F;cardUsers were being redirected to the home page after login, which is lessuseful than redirecting to the page they had originally requested beforebeing redirected to the login form.* Store requested path in a session variable* Redirect to the stored location after successfully logging in the user 推荐工具 SourceTree SourceTree集成了Git Flow功能，能简单方便的操作和实现常规的工作流程。支持OSX和Windows平台。 Git Flow 扩展 Git Flow模型提出者nvie写的Git命令集扩展，提供了极出色的命令帮助以及输出提示。支持OSX，Linux和Windows平台","categories":[{"name":"开发规范","slug":"开发规范","permalink":"https://waltonmax.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"git","slug":"git","permalink":"https://waltonmax.github.io/tags/git/"}]},{"title":"GitHub语义化版本 2.0.0","slug":"git-semantic-versioning","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T10:08:42.246Z","comments":false,"path":"2020/08/12/git-semantic-versioning/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/git-semantic-versioning/","excerpt":"","text":"摘要 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。 先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 简介 在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。 在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。 作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。 我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。 语义化版本控制规范（SemVer） 以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。（译注：为了保持语句顺畅， 以下文件遇到的关键词将依照整句语义进行翻译，在此先不进行个别翻译。） 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 修订号 Z（x.y.Z | x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。 主版本号 X（X.y.z | X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译元数据可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译元数据可（SHOULD）被忽略。因此当两个版本只有在版本编译元数据有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译元数据不在这份比较的列表中）。由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha &lt; 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符比非数字的标识符优先层级低。若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。 为什么要使用语义化的版本控制？ 这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。 举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函式库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能， 你可以放心地指定依赖于梯子的版本号大等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。 作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。 如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函式库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页连结，让别人也知道这些规则并从中受益。 FAQ 在 0.y.z 初始开发阶段，我该如何进行版本控制？ 最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。 如何判断发布 1.0.0 版本的时机？ 当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。 这不会阻碍快速开发和迭代吗？ 主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。 对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？ 这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。 为整个公共 API 写文件太费事了！ 为供他人使用的软件编写适当的文件，是你作为一名专业开发者应尽的职责。保持专案高效一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。 万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？ 一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文件中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。 如果我更新了自己的依赖但没有改变公共 API 该怎么办？ 由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。 如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中） 自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。 我该如何处理即将弃用的功能？ 弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文件让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。 语义化版本对于版本的字串长度是否有限制呢？ 没有，请自行做适当的判断。举例来说，长到 255 个字元的版本已过度夸张。再者，特定的系统对于字串长度可能会有他们自己的限制。","categories":[{"name":"开发规范","slug":"开发规范","permalink":"https://waltonmax.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"版本","slug":"版本","permalink":"https://waltonmax.github.io/tags/%E7%89%88%E6%9C%AC/"}]},{"title":"git 使用","slug":"git-use","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T09:53:42.789Z","comments":false,"path":"2020/08/12/git-use/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/git-use/","excerpt":"","text":"命令: 12345678910111213git init #初始化本地git库git add . #添加当前所有文件到git库git commit -m &quot;first commit&quot; #提交到本地库git remote add origin git@github.com:waltonmax/test.git #添加远程仓库地址 git push -u origin master #推送到远程仓库git branch &lt;name&gt; #创建分支git checkout &lt;name&gt; #切换分支git checkout -b &lt;name&gt; #创建+切换分支git merge &lt;name&gt; #合并某分支到当前分支git branch -d &lt;name&gt; #删除分支curl -u &#x27;用户名&#x27; https://api.github.com/user/repos -d &#x27;&#123;&quot;name&quot;:&quot;仓库名&quot;&#125;&#x27; #使用命令创建远程仓库 常见问题解决 1234#版本控制无效git rm -r --cached .git add .git commit -m &#39;update .gitignore&#39;","categories":[{"name":"开发工具使用","slug":"开发工具使用","permalink":"https://waltonmax.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"git","slug":"git","permalink":"https://waltonmax.github.io/tags/git/"},{"name":"bash","slug":"bash","permalink":"https://waltonmax.github.io/tags/bash/"}]},{"title":"liux中profile、bashrc、bash_profile作用与区别","slug":"liux-profile-bash-profile-bashrc-use","date":"2020-08-12T12:31:41.000Z","updated":"2020-08-13T09:22:52.589Z","comments":false,"path":"2020/08/12/liux-profile-bash-profile-bashrc-use/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/liux-profile-bash-profile-bashrc-use/","excerpt":"","text":"/etc/profile，/etc/bashrc 是系统全局环境变量设定 ~/.profile，~/.bashrc用户家目录下的私有环境变量设定 当登入系统时候获得一个shell进程时，其读取环境设定档有三步: 首先读入的是全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如/etc/profile.d和/etc/inputrc 然后根据不同使用者帐号，去读取~/.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取~/.profile，这三个文档设定基本上是一样的, 读取有优先关系. 然后在根据用户帐号读取~/.bashrc 至于~/.profile与~/.bashrc,它们都具有个性化定制功能. ~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次. ~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次","categories":[{"name":"liux","slug":"liux","permalink":"https://waltonmax.github.io/categories/liux/"}],"tags":[{"name":"liux","slug":"liux","permalink":"https://waltonmax.github.io/tags/liux/"}]},{"title":"hexo 部署","slug":"hexo-deployment","date":"2020-08-12T09:33:20.000Z","updated":"2020-08-12T13:04:31.189Z","comments":false,"path":"2020/08/12/hexo-deployment/","link":"","permalink":"https://waltonmax.github.io/2020/08/12/hexo-deployment/","excerpt":"","text":"部署 12345$ npm install -g hexo-cli #安装$ hexo init #初始化$ hexo g #生成$ hexo s #启动本地服务$ hexo d #发布 常用命令 123456789$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）$ hexo deploy #将.deploy目录部署到GitHub$ hexo help # 查看帮助$ hexo version #查看Hexo的版本$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d #一键发布(liux)$ hexo clean ; hexo g ; hexo d #一键发布(windows)","categories":[{"name":"前端","slug":"前端","permalink":"https://waltonmax.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://waltonmax.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-08-11T02:36:32.212Z","updated":"2020-08-12T13:08:03.420Z","comments":false,"path":"2020/08/11/hello-world/","link":"","permalink":"https://waltonmax.github.io/2020/08/11/hello-world/","excerpt":"","text":"Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; Run server 1$ hexo server Generate static files 1$ hexo generate Deploy to remote sites 1$ hexo deploy","categories":[{"name":"test","slug":"test","permalink":"https://waltonmax.github.io/categories/test/"}],"tags":[{"name":"test-tag","slug":"test-tag","permalink":"https://waltonmax.github.io/tags/test-tag/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://waltonmax.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"开发规范","slug":"开发规范","permalink":"https://waltonmax.github.io/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"name":"开发工具使用","slug":"开发工具使用","permalink":"https://waltonmax.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"liux","slug":"liux","permalink":"https://waltonmax.github.io/categories/liux/"},{"name":"前端","slug":"前端","permalink":"https://waltonmax.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"test","slug":"test","permalink":"https://waltonmax.github.io/categories/test/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://waltonmax.github.io/tags/mongodb/"},{"name":"mysql","slug":"mysql","permalink":"https://waltonmax.github.io/tags/mysql/"},{"name":"git","slug":"git","permalink":"https://waltonmax.github.io/tags/git/"},{"name":"版本","slug":"版本","permalink":"https://waltonmax.github.io/tags/%E7%89%88%E6%9C%AC/"},{"name":"bash","slug":"bash","permalink":"https://waltonmax.github.io/tags/bash/"},{"name":"liux","slug":"liux","permalink":"https://waltonmax.github.io/tags/liux/"},{"name":"hexo","slug":"hexo","permalink":"https://waltonmax.github.io/tags/hexo/"},{"name":"test-tag","slug":"test-tag","permalink":"https://waltonmax.github.io/tags/test-tag/"}]}